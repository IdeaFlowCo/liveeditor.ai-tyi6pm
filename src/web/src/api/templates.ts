/**
 * API service module for interacting with template-related endpoints
 * 
 * Handles fetching, creating, updating, and deleting AI prompt templates
 * used for document enhancement suggestions.
 * 
 * @module templates
 * @version 1.0.0
 */

import { get, post, put, delete as del } from '../utils/api';
import { ENDPOINTS } from '../constants/api';
import { PromptTemplate } from '../types/ai';

// Local storage key for recently used templates
const RECENT_TEMPLATES_KEY = 'recent_templates';
const MAX_RECENT_TEMPLATES = 5;

/**
 * Fetches all available prompt templates from the backend
 * 
 * @param params - Optional query parameters for filtering templates
 * @returns Promise resolving to array of prompt templates
 */
export const getTemplates = async (params?: {
  category?: string;
  isSystem?: boolean;
}): Promise<PromptTemplate[]> => {
  return get<PromptTemplate[]>(ENDPOINTS.TEMPLATES.BASE, params);
};

/**
 * Fetches a specific prompt template by its ID
 * 
 * @param id - Unique identifier of the template
 * @returns Promise resolving to the requested template
 * @throws ApiError if the template is not found
 */
export const getTemplateById = async (id: string): Promise<PromptTemplate> => {
  if (!id) {
    throw new Error('Template ID is required');
  }
  return get<PromptTemplate>(ENDPOINTS.TEMPLATES.TEMPLATE(id));
};

/**
 * Fetches the list of available template categories
 * 
 * @returns Promise resolving to array of category names
 */
export const getTemplateCategories = async (): Promise<string[]> => {
  return get<string[]>(ENDPOINTS.TEMPLATES.CATEGORIES);
};

/**
 * Creates a new custom prompt template
 * 
 * @param templateData - Template data without ID (generated by the server)
 * @returns Promise resolving to the newly created template with assigned ID
 * @throws ApiError if validation fails or creation is not allowed
 */
export const createTemplate = async (
  templateData: Omit<PromptTemplate, 'id'>
): Promise<PromptTemplate> => {
  // Validate required fields
  if (!templateData.name || !templateData.promptText || !templateData.category) {
    throw new Error('Template name, promptText, and category are required');
  }
  
  return post<PromptTemplate>(ENDPOINTS.TEMPLATES.BASE, templateData);
};

/**
 * Updates an existing prompt template
 * 
 * @param id - ID of the template to update
 * @param templateData - Partial template data with fields to update
 * @returns Promise resolving to the updated template
 * @throws ApiError if the template is not found or update is not allowed
 */
export const updateTemplate = async (
  id: string,
  templateData: Partial<PromptTemplate>
): Promise<PromptTemplate> => {
  if (!id) {
    throw new Error('Template ID is required');
  }
  
  return put<PromptTemplate>(ENDPOINTS.TEMPLATES.TEMPLATE(id), templateData);
};

/**
 * Deletes a prompt template by its ID
 * 
 * @param id - ID of the template to delete
 * @returns Promise resolving to success status
 * @throws ApiError if the template is not found or deletion is not allowed
 */
export const deleteTemplate = async (
  id: string
): Promise<{ success: boolean }> => {
  if (!id) {
    throw new Error('Template ID is required');
  }
  
  return del<{ success: boolean }>(ENDPOINTS.TEMPLATES.TEMPLATE(id));
};

/**
 * Saves a template ID to local storage as recently used
 * 
 * Maintains a list of the 5 most recently used templates for quick access
 * 
 * @param templateId - ID of the template to mark as recently used
 */
export const saveRecentlyUsedTemplate = (templateId: string): void => {
  try {
    // Get existing recently used templates
    const recentTemplatesJson = localStorage.getItem(RECENT_TEMPLATES_KEY);
    let recentTemplates: string[] = recentTemplatesJson 
      ? JSON.parse(recentTemplatesJson) 
      : [];
    
    // Remove the template ID if it already exists to avoid duplicates
    recentTemplates = recentTemplates.filter(id => id !== templateId);
    
    // Add the new template ID to the beginning of the array
    recentTemplates.unshift(templateId);
    
    // Limit to the maximum number of recent templates
    if (recentTemplates.length > MAX_RECENT_TEMPLATES) {
      recentTemplates = recentTemplates.slice(0, MAX_RECENT_TEMPLATES);
    }
    
    // Save back to local storage
    localStorage.setItem(RECENT_TEMPLATES_KEY, JSON.stringify(recentTemplates));
  } catch (error) {
    console.error('Error saving recently used template:', error);
  }
};